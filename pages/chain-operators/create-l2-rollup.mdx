import { Callout, Steps } from 'nextra/components'

# Creating Your Own L2 Rollup

<Callout type="info">
This quickstart guide is designed to get you familiar with all of the components that make up the OP Stack.
Please **be prepared to set aside approximately one hour** to get everything running properly and **make sure to read through the guide carefully**.
You don't want to miss any important steps that might cause issues down the line.
</Callout>

This Getting Started quickstart guide is **designed for developers** who want to learn about the OP Stack by spinning up an OP Stack testnet chain.
In this tutorial we'll walk through the full deployment process and **you'll end up with your very own OP Stack testnet**.

You can use this testnet to experiment and perform tests or you can choose to modify the chain to adapt it to your own needs.
**The OP Stack is free (as in freedom) and open source software licensed entirely under the MIT license**.
You don't need permission from anyone to modify or deploy the stack in any configuration you want.

<Callout>
Modifications to the OP Stack may prevent a chain from being able to benefit from aspects of the [Optimism Superchain](/op-stack/explainer).
Make sure to check out the [Superchain Explainer](/op-stack/explainer) to learn more.
</Callout>

## What We're Going to Deploy

When deploying an OP Stack chain, you'll be setting up five different components.
It's useful to understand what each of these components does before you start deploying your chain.

### Smart Contracts

The OP Stack gives you the ability to deploy your own Rollup chains that use a Layer 1 blockchain to host and order transaction data.
OP Stack chains use several smart contracts on the L1 blockchain to manage aspects of the Rollup.
Each OP Stack chain has its own set of L1 smart contracts that are deployed when the chain is created.
We'll be using the L1 smart contracts found in the [`contracts-bedrock` package](https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts-bedrock) within the [Optimism Monorepo](https://github.com/ethereum-optimism/optimism).

### Consensus Client

OP Stack nodes, like Ethereum nodes, have a consensus client.
The consensus client is responsible for determining the list and ordering of blocks and transactions that are part of your blockchain.
Several implementations of the OP Stack consensus client exist, including `op-node` (maintained by OP Labs) and [`magi`](https://github.com/a16z/magi) (maintained by a16z).
In this tutorial we'll be using the [`op-node` implementation](https://github.com/ethereum-optimism/optimism/tree/develop/op-node) found within the [Optimism Monorepo](https://github.com/ethereum-optimism/optimism).

### Execution Client

OP Stack nodes, like Ethereum nodes, also have an execution client.
The execution client is responsible to executing transactions and storing/updating the state of the blockchain.
Various implementations of the OP Stack execution client exist, including `op-geth` (maintained by OP Labs), [`op-erigon`](https://github.com/testinprod-io/op-erigon) (maintained by Test in Prod), and `op-nethermind` (coming soon).
In this tutorial we'll be using the [`op-geth` implementation](https://github.com/ethereum-optimism/op-geth) found within the [`op-geth` repository](https://github.com/ethereum-optimism/op-geth).

### Batcher

The Batcher is an entity for publishing transactions from the Sequencer to the L1 blockchain.
The Batcher runs continuously alongside the Sequencer and publishes transactions in batches (hence the name) on a regular basis.
We'll be using the [`op-batcher` implementation](https://github.com/ethereum-optimism/optimism/tree/develop/op-batcher) of the Batcher component found within the [Optimism Monorepo](https://github.com/ethereum-optimism/optimism).

### Proposer

The Proposer is an entity responsible for publishing transactions *results* (in the form of L2 state roots) to the L1 blockchain.
This allows smart contracts on L1 to read the state of the L2, which is necessary for cross-chain communication and user withdrawals.
It's likely that the Proposer will be removed in the future, but for now it's a necessary component of the OP Stack.
We'll be using the [`op-proposer` implementation](https://github.com/ethereum-optimism/optimism/tree/develop/op-proposer) of the Proposer component found within the [Optimism Monorepo](https://github.com/ethereum-optimism/optimism).

## Software Dependencies

- [git](https://git-scm.com/)
- [go](https://go.dev/)
- [node](https://nodejs.org/en/)
- [pnpm](https://pnpm.io/installation)
- [foundry](https://github.com/foundry-rs/foundry#installation)
- [make](https://linux.die.net/man/1/make)
- [jq](https://github.com/jqlang/jq)
- [direnv](https://direnv.net)

### Notes on Specific Dependencies

#### `node`

We recommend using the latest LTS version of Node.js (currently v20).
[`nvm`](https://github.com/nvm-sh/nvm) is a useful tool that can help you manage multiple versions of Node.js on your machine.
You may experience unexpected errors on older versions of Node.js.

#### `direnv`

Parts of this tutorial use [`direnv`](https://direnv.net) as a way of loading environment variables from `.envrc` files into your shell.
This means you won't have to manually export environment variables every time you want to use them.
`direnv` only ever has access to files that you explicitly allow it to see.

After [installing `direnv`](https://direnv.net/docs/installation.html), you will need to **make sure that [`direnv` is hooked into your shell](https://direnv.net/docs/hook.html)**.
Make sure you've followed [the guide on the `direnv` website](https://direnv.net/docs/hook.html), then **close your terminal and reopen it** so that the changes take effect.

## Get Access to a Goerli Node

We'll be deploying a OP Stack Rollup chain that uses a Layer 1 blockchain to host and order transaction data.
The OP Stack Rollups were designed to use EVM Equivalent blockchains like Ethereum, OP Mainnet, or standard Ethereum testnets as their L1 chains.

**This guide uses the Goerli testnet as an L1 chain**.
We recommend that you also use Goerli (Sepolia should also be fine, but use Goerli if you don't want to edit any commands).
You can also use use other EVM-compatible blockchains, but you may run into unexpected errors.
If you want to use an alternative network, make sure to carefully review each command and replace any Goerli-specific values with the values for your network.

Since we're deploying our OP Stack chain to Goerli, you'll need to have access to a Goerli node.
You can either use a node provider like [Alchemy](https://www.alchemy.com/) (easier) or [run your own Goerli node](https://notes.ethereum.org/@launchpad/goerli) (harder).

## Build the Source Code

We're going to be spinning up our OP Stack chain directly from source code instead of using a container system like [Docker](https://www.docker.com/).
Although this adds a few extra steps, it means you'll have an easier time modifying the behavior of the stack if you'd like to do so.
If you want a summary of the various components we'll be using, take another look at the [What We're Going to Deploy](#what-were-going-to-deploy) section above.

### Build the Optimism Monorepo

<Steps>

{<h3>Clone the Optimism Monorepo</h3>}

```bash
cd ~
git clone https://github.com/ethereum-optimism/optimism.git
```

{<h3>Enter the Optimism Monorepo</h3>}

```bash
cd optimism
```

{<h3>Install dependencies</h3>}

```bash
pnpm install
```

{<h3>Build the various packages inside of the Optimism Monorepo</h3>}

```bash
make op-node op-batcher op-proposer
pnpm build
```

</Steps>

### Build `op-geth`

<Steps>

{<h3>Clone op-geth</h3>}

```bash
cd ~
git clone https://github.com/ethereum-optimism/op-geth.git
```

{<h3>Enter op-geth</h3>}

```bash
cd op-geth
```

{<h3>Build op-geth</h3>}

```bash
make geth
```

</Steps>

## Generate and Fund Accounts

You'll need four accounts and their private keys when setting up the chain:

- The `Admin` account has the ability to upgrade contracts.
- The `Batcher` account publishes Sequencer transaction data to L1.
- The `Proposer` account publishes L2 transaction results (state roots) to L1.
- The `Sequencer` account signs blocks on the p2p network.

<Steps>

{<h3>Enter the Optimism Monorepo</h3>}

```bash
cd optimism
```

{<h3>Generate new accounts</h3>}

<Callout type="error"> 
You should **not** use the `cast wallet new` tool for production deployments.
If you are deploying an OP Stack based chain into production, you should likely be using a combination of hardware security modules and hardware wallets.
</Callout>

```bash
echo "Admin:"
cast wallet new
echo "Proposer:"
cast wallet new
echo "Batcher:"
cast wallet new
echo "Sequencer:"
cast wallet new
```

{<h3>Check the output</h3>}
Make sure that you see output that looks something like the following:

```
Admin:
Successfully created new keypair.
Address:     0x9f92bdF0db69264462FC305913960Edfcc7a7c7F
Private key: 0x30e66956e1a12b81f0f2cfb982286b2f566eb73649833831d9f80b12f8fa183c
Proposer:
Successfully created new keypair.
Address:     0x31dE9B6473fc47af36ec23878bA34824B9F4AB30
Private key: 0x8bd1c8dfffef880f8f9ab8162f97ccd119c1aac28fe00dacf919459f88e0f37d
Batcher:
Successfully created new keypair.
Address:     0x6A3DC843843139f17Fcf04C057bb536A421DC9c6
Private key: 0x3ce44144b7fde797a28f4e47b210a4d42c3a3b642e538b54458cba2740db5ac2
Sequencer:
Successfully created new keypair.
Address:     0x98C6cadB1fe77aBB7bD968fC3E9b206111e72848
Private key: 0x3f4241229bb6f155140d98e0f5dd2aad7ae983f5af5d61555d05eb8e5d9514db
```

{<h3>Save the accounts</h3>}

Make sure to save these accounts and their respective private keys somewhere, you'll need them later in this guide.
A text file is fine since you won't be using these keys in production (seriously, don't use these in production).

{<h3>Fund the accounts</h3>}

**You will need to send ETH to the `Admin`, `Proposer`, and `Batcher` accounts.**
You do not need to send any ETH to the `Sequencer` account as it does not send transactions.
The exact amount of ETH required depends on the L1 network being used.
We recommend funding the accounts with the following amounts when using Goerli:

- `Admin` — 2 ETH
- `Proposer` — 5 ETH
- `Batcher` — 10 ETH

</Steps>

## Fill Out And Load Environment variables

Now that you've generated your four accounts, you'll need to fill our your environment variable file.

<Steps>

{<h3>Enter the Optimism Monorepo</h3>}

```bash
cd ~/optimism
```

{<h3>Duplicate the sample environment variable file</h3>}

```bash
cp .envrc.example .envrc
```

{<h3>Fill out the environment variable file</h3>}

Open up the environment variable file and fill out the following variables:

| Variable Name | Description |
| --- | --- |
| `GS_ADMIN_ADDRESS` | Address of the `Admin` account. |
| `GS_ADMIN_PRIVATE_KEY` | Private key of the `Admin` account. |
| `GS_BATCHER_ADDRESS` | Address of the `Batcher` account. |
| `GS_BATCHER_PRIVATE_KEY` | Private key of the `Batcher` account. |
| `GS_PROPOSER_ADDRESS` | Address of the `Proposer` account. |
| `GS_PROPOSER_PRIVATE_KEY` | Private key of the `Proposer` account. |
| `GS_SEQUENCER_ADDRESS` | Address of the `Sequencer` account. |
| `GS_SEQUENCER_PRIVATE_KEY` | Private key of the `Sequencer` account. |
| `L1_RPC_URL` | URL for your L1 node. |
| `L1_RPC_KIND` | Kind of L1 RPC you're connecting to, used to inform optimal transactions receipts fetching. Valid options: `alchemy`, `quicknode`, `infura`, `parity`, `nethermind`, `debug_geth`, `erigon`, `basic`, `any`. |

{<h3>Load the variables with direnv</h3>}

<Callout>
We're about to use `direnv` to load environment variables from the `.envrc` file into our terminal.
Make sure that you've [installed `direnv`](https://direnv.net/docs/installation.html) and that you've properly [hooked `direnv` into your shell](#configuring-direnv).
</Callout>

Next you'll need to allow `direnv` to read this file and load the variables into your terminal using the following command.
It's very important to note that `direnv` will unload these variables if the file is changed.
You *must* rerun the following command every time you change the `.envrc` file.

```bash
direnv allow .
```

<Callout type="info">
When you run `direnv allow .` you should see output something like the following (may not be exact but should be mostly the same).

```bash
direnv: loading ~/Projects/optimism/packages/contracts-bedrock/.envrc
direnv: export +DEPLOYMENT_CONTEXT +ETHERSCAN_API_KEY +ETH_RPC_URL +IMPL_SALT +PRIVATE_KEY +TENDERLY_PROJECT +TENDERLY_USERNAME
```

If you don't see this output, you likely haven't [properly configured `direnv`](#configuring-direnv).
Make sure you've configured `direnv` properly before running `direnv allow .` again.
</Callout>
</Steps>

## Configure your network

Once you've built both repositories, you'll need head back to the Optimism Monorepo to set up the configuration file for your chain.
Currently, chain configuration lives inside of the [`contracts-bedrock`](https://github.com/ethereum-optimism/optimism/tree/129032f15b76b0d2a940443a39433de931a97a44/packages/contracts-bedrock) package in the form of a JSON file.

<Steps>
{<h3>Enter the Optimism Monorepo</h3>}

```bash
cd ~/optimism
```

{<h3>Move into the contracts-bedrock package</h3>}

```bash
cd packages/contracts-bedrock
```

{<h3>Generate the configuration file</h3>}

Run the following script to generate the `getting-started.json` configuration file inside of the `deploy-config` directory.

```bash
./scripts/getting-started-config.sh
```

{<h3>Review the configuration file (Optional)</h3>}

If you'd like, you can review the configuration file that was just generated by opening up `deploy-config/getting-started.json` in your favorite text editor.
We recommend keeping this file as-is for now so you don't run into any unexpected errors.

</Steps>

## Deploy the L1 contracts

Once you've configured your network, it's time to deploy the L1 contracts necessary for the functionality of the chain.

<Steps>
{<h3>Create the deployment directory</h3>}

```bash
mkdir deployments/getting-started
```


{<h3>Deploy the L1 contracts</h3>}

```bash
forge script scripts/Deploy.s.sol:Deploy --private-key $GS_ADMIN_PRIVATE_KEY --broadcast --rpc-url $L1_RPC_URL
```

{<h3>Generate contract artifacts</h3>}

```bash
forge script scripts/Deploy.s.sol:Deploy --sig 'sync()' --rpc-url $L1_RPC_URL
```

</Steps>

## Generate the L2 config files

Now that we've set up the L1 smart contracts we can automatically generate several configuration files that are used within the Consensus Client and the Execution Client.

We need to generate three important files:

1. `genesis.json` includes the genesis state of the chain for the Execution Client.
1. `rollup.json` includes configuration information for the Consensus Client.
1. `jwt.txt` is a [JSON Web Token](https://jwt.io/introduction) that allows the Consensus Client and the Execution Client to communicate securely (the same mechanism is used in Ethereum clients).

<Steps>
{<h3>Navigate to the op-node package</h3>}

```bash
cd ~/optimism/op-node
```

{<h3>Create genesis files</h3>}

Now we'll generate the `genesis.json` and `rollup.json` files within the `op-node` folder:

```bash
go run cmd/main.go genesis l2 \
    --deploy-config ../packages/contracts-bedrock/deploy-config/getting-started.json \
    --deployment-dir ../packages/contracts-bedrock/deployments/getting-started/ \
    --outfile.l2 genesis.json \
    --outfile.rollup rollup.json \
    --l1-rpc $ETH_RPC_URL
```

{<h3>Create an authentication key</h3>}

Next you'll create a [JSON Web Token](https://jwt.io/introduction) that will be used to authenticate the Consensus Client and the Execution Client.
This token is used to ensure that only the Consensus Client and the Execution Client can communicate with each other.
You can generate a JWT with the following command:

```bash
openssl rand -hex 32 > jwt.txt
```

{<h3>Copy genesis files into the op-geth directory</h3>}

Finally, we'll need to copy the `genesis.json` file and `jwt.txt` file into `op-geth` so we can use it to initialize and run `op-geth`:

```bash
cp genesis.json ~/op-geth
cp jwt.txt ~/op-geth
```

</Steps>

## Initialize `op-geth`

We're almost ready to run our chain!
Now we just need to run a few commands to initialize `op-geth`.
We're going to be running a Sequencer node, so we'll need to import the `Sequencer` private key that we generated earlier.
This private key is what our Sequencer will use to sign new blocks.

<Steps>

{<h3>Navigate to the op-geth directory</h3>}

```bash
cd ~/op-geth
```

{<h3>Create a data directory folder</h3>}

```bash
mkdir datadir
```

{<h3>Initialize op-geth</h3>}

Next we need to initialize `op-geth` with the genesis file we generated and copied earlier:

```bash
build/bin/geth init --datadir=datadir genesis.json
```

</Steps>

## Start `op-geth`

Now we'll start `op-geth`, our Execution Client.
Note that you won't start seeing any transactions until you start the Consensus Client in the next step.

<Steps>
{<h3>Navigate to the op-geth directory</h3>}

```bash
cd ~/op-geth
```

{<h3>Run op-geth</h3>}

<Callout type="info">
We're using `--gcmode=archive` to run `op-geth` here because this node will act as our Sequencer.
It's useful to run the Sequencer in archive mode because the `op-proposer` requires access to the full state.
Feel free to run other (non-Sequencer) nodes in full mode if you'd like to save disk space.
</Callout>

```bash
./build/bin/geth \
    --datadir ./datadir \
    --http \
    --http.corsdomain="*" \
    --http.vhosts="*" \
    --http.addr=0.0.0.0 \
    --http.api=web3,debug,eth,txpool,net,engine \
    --ws \
    --ws.addr=0.0.0.0 \
    --ws.port=8546 \
    --ws.origins="*" \
    --ws.api=debug,eth,txpool,net,engine \
    --syncmode=full \
    --gcmode=archive \
    --nodiscover \
    --maxpeers=0 \
    --networkid=42069 \
    --authrpc.vhosts="*" \
    --authrpc.addr=0.0.0.0 \
    --authrpc.port=8551 \
    --authrpc.jwtsecret=./jwt.txt \
    --rollup.disabletxpoolgossip=true
```

</Steps>


## Start `op-node`

Once we've got `op-geth` running we'll need to run `op-node`.
Like Ethereum, the OP Stack has a Consensus Client (`op-node`) and an Execution Client (`op-geth`). 
The Consensus Client "drives" the Execution Client over the Engine API.

<Steps>
{<h3>Navigate to the op-node directory</h3>}

```bash
cd ~/optimism/op-node
```

{<h3>Run op-node</h3>}

```bash
./bin/op-node \
	--l2=http://localhost:8551 \
	--l2.jwt-secret=./jwt.txt \    
	--sequencer.enabled \
	--sequencer.l1-confs=5 \
	--verifier.l1-confs=4 \
	--rollup.config=./rollup.json \
	--rpc.addr=0.0.0.0 \
	--rpc.port=8547 \
	--p2p.disable \
	--rpc.enable-admin \
	--p2p.sequencer.key=$GS_SEQUENCER_PRIVATE_KEY \
	--l1=$L1_RPC_URL \
	--l1.rpckind=$L1_RPC_KIND
```

Once you run this command, you should start seeing the `op-node` begin to sync L2 blocks from the L1 chain.
Once the `op-node` has caught up to the tip of the L1 chain, it'll begin to send blocks to `op-geth` for execution.
At that point, you'll start to see blocks being created inside of `op-geth`.

<Callout type="info">
**By default, your `op-node` will try to use a peer-to-peer to speed up the synchronization process.**
If you're using a chain ID that is also being used by others, like the default chain ID for this tutorial (42069), your `op-node` will receive blocks signed by other sequencers.
These requests will fail and waste time and network resources.
**To avoid this, we start with peer-to-peer synchronization disabled (`--p2p.disable`).**

Once you have multiple nodes, you may want to enable peer-to-peer synchronization.
You can add the following options to the `op-node` command to enable peer-to-peer synchronization with specific nodes:

```
	--p2p.static=<nodes> \
	--p2p.listen.ip=0.0.0.0 \
	--p2p.listen.tcp=9003 \
	--p2p.listen.udp=9003 \
```

You can alternatively also remove the `--p2p.static` option but you may see failed requests from other chains using the same chain ID.

</Callout>

</Steps>


## Start `op-batcher`

The `op-batcher` takes transactions from the Sequencer and publishes those transactions to L1.
Once these Sequencer transactions are included in a finalized L1 block, they're officially part of the canonical chain.
The `op-batcher` is critical!

It's best to give the `Batcher` account at least 1 Goerli ETH to ensure that it can continue operating without running out of ETH for gas.
Keep an eye on the balance of the `Batcher` account because it can expend ETH quickly if there are a lot of transactions to publish.

<Steps>

{<h3>Navigate to the op-batcher directory</h3>}

```bash
cd ~/optimism/op-batcher
```

{<h3>Run op-batcher</h3>}

```bash
./bin/op-batcher \
    --l2-eth-rpc=http://localhost:8545 \
    --rollup-rpc=http://localhost:8547 \
    --poll-interval=1s \
    --sub-safety-margin=6 \
    --num-confirmations=1 \
    --safe-abort-nonce-too-low-count=3 \
    --resubmission-timeout=30s \
    --rpc.addr=0.0.0.0 \
    --rpc.port=8548 \
    --rpc.enable-admin \
    --max-channel-duration=1 \
    --l1-eth-rpc=$L1_RPC_URL \
    --private-key=$GS_BATCHER_PRIVATE_KEY
```


<Callout type="info">
The `--max-channel-duration=n` setting tells the batcher to write all the data to L1 every `n` L1 blocks.
When it is low, transactions are written to L1 frequently and other nodes can synchronize from L1 quickly.
When it is high, transactions are written to L1 less frequently and the batcher spends less ETH.
If you want to reduce costs, either set this value to 0 to disable it or increase it to a higher value.
</Callout>

</Steps>

## Start `op-proposer`

Now start `op-proposer`, which proposes new state roots.

<Steps>

{<h3>Navigate to the op-proposer directory</h3>}

```bash
cd ~/optimism/op-proposer
```

{<h3>Load the address of the L2OutputOracleProxy Contract</h3>}

We'll need to access the address of the L2OutputOracleProxy contract for this next step.
Load the address as an environment variable with the following command.

```bash
export L2_OUTPUT_ORACLE_PROXY_ADDRESS="cat ../packages/contracts-bedrock/deployments/getting-started/L2OutputOracleProxy.json | jq -r .address"
```

{<h3>Run op-proposer</h3>}

```bash
./bin/op-proposer \
    --poll-interval=12s \
    --rpc.port=8560 \
    --rollup-rpc=http://localhost:8547 \
    --l2oo-address=$L2_OUTPUT_ORACLE_PROXY_ADDRESS \
    --private-key=$GS_PROPOSER_PRIVATE_KEY \
    --l1-eth-rpc=$L1_RPC_URL
```

</Steps>

## Get some ETH on your Rollup

Once you’ve connected your wallet, you’ll probably notice that you don’t have any ETH on your Rollup. You’ll need some ETH to pay for gas on your Rollup. The easiest way to deposit Goerli ETH into your chain is to send funds directly to the `L1StandardBridge` contract. You can find the address of the `L1StandardBridge` contract for your chain by looking inside the `deployments` folder in the `contracts-bedrock` package.

<Steps>
{<h3>Navigate to the contracts-bedrock directory</h3>}

```bash
cd ~/optimism/packages/contracts-bedrock
```

{<h3>Get the address of the L1StandardBridgeProxy contract</h3>}

```bash
cat deployments/getting-started/L1StandardBridgeProxy.json | jq -r .address
```

{<h3>Send some Goerli ETH to the L1StandardBridgeProxy contract</h3>}

Grab the L1 bridge proxy contract address and, using the wallet that you want to have ETH on your Rollup, send that address a small amount of ETH on Goerli (0.1 or less is fine). 
It may take up to 5 minutes for that ETH to appear in your wallet on L2.

</Steps>

Congratulations, you made it! You now have a complete OP Stack based EVM Rollup.

## See Your Rollup in Action
To see your rollup in action, follow these steps:

<Steps>
{<h3>Make a project folder and initialize it</h3>}

```bash
mkdir project-folder-name
cd folder-name
pnpm init
```

{<h3>Install the dependencies</h3>}

```bash
pnpm add @eth-optimism/contracts@^0.5.40
```

{<h3>Create a Greeter.sol file</h3>}

```solidity filename="Greeter.sol"
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract Greeter {
  string greeting;

  constructor(string memory _greeting) {
    greeting = _greeting;
  }

  function greet() public view returns (string memory) {
    return greeting;
  }

  function setGreeting(string memory _greeting) public {
    greeting = _greeting;
  }
}
```

{<h3>Create mnem.delme file & add your mnemonic to it </h3>}

Your mnemonic is for the address where you have ETH, the one that sent ETH to `OptimismPortalProxy` on Goerli. 
Take that info and put it in a file `mnem.delme`.

{<h3>Provide the URL to your blockchain</h3>}

```bash
export ETH_RPC_URL=http://localhost:8545
```

{<h3>Compile and deploy the Greeter contract</h3>}

```bash
forge create --mnemonic-path ./mnem.delme Greeter --constructor-args "hello" | tee deployment.log
```

{<h3>Set the greeter to the deployed to address</h3>}

```bash
export GREETER=`cat deployment.log | awk '/Deployed to:/ {print $3}'`
echo $GREETER
```

{<h3>See and modify the greeting</h3>}

```bash
cast call $GREETER "greet()" | cast --to-ascii
cast send --mnemonic-path ./mnem.delme $GREETER "setGreeting(string)" "New greeting"
cast call $GREETER "greet()" | cast --to-ascii
```

</Steps>

<Callout type="info">
To use any other development stack, just replace the Greeter address with the address of your rollup, and the Optimism Goerli URL with `http://localhost:8545`.
</Callout>

## Next Steps

- You can use this rollup the same way you’d use any other test blockchain. Once the superchain is available, this blockchain should be able to join the test version. 
- Alternatively, you could [modify the blockchain in various ways](hacks/overview). 
- If you run into any problems, please visit the [Chain Operators Troubleshooting Guide](chain-troubleshooting) for help.

<Callout type="info">
**Please note that OP Stack Hacks are unofficial and are not explicitly supported by the OP Stack.** 
You will not be able to receive significant developer support for any modifications you make to the OP Stack.
</Callout>

